#include <stdio.h>#include <stdlib.h>#include <memory.h>#include <unistd.h>#include <iostream>#include<fstream>#include<sstream>#include <string.h>#define VERTIX 200using namespace std;void random(int* node1, int* node2){	int num = rand() % (200*200);	*node1 = (int)(num/200);	*node2 = num%200;	return;}int vertix1, vertix2 = 0;int contract_array_index = 0;int contract_array[VERTIX];int num =0;int node_index, node2_index = 0;int **graph2;char buffer[8];FILE* log_txt;//int totalVertix = VERTIX;void contract_another_graph(int contracter, int contract, int another_contract_point){	printf("contract another graph\n");	for(int i =0; i< VERTIX; i++)	{		if(graph2[ another_contract_point -1][i] == contracter)		{			graph2[ another_contract_point -1][i] = contract;		}		//sprintf(buffer ,"%d ", graph2[ another_contract_point -1][i]);		//fwrite(buffer, 1, sizeof(buffer) +1, log_txt);	}	return;	}void contract_graph(int total_vertix){	int node1, node2 =0;	num = rand() % (200*200);	node1 = (int)(num/200);	node2 = num%200;		while(1)	{				if(total_vertix <= 2) 			break;		printf("\n\ncontract_ grpah %d %d %d \n", node1, node2, total_vertix);		vertix1 = graph2[node1][0];		vertix2 = graph2[node1][node2];		printf("vertix1 vertix2 %d %d\n", vertix1, vertix2);				if(vertix2 == 0 || vertix1 == 0 || vertix1 >200 || vertix2 >200)		{			num = rand() % (200*200);			node1 = (int)(num/200);			node2 = num%200;			//contract_graph(node_index, node2_index, graph, total_vertix);			continue;						}		memset(contract_array, 0, VERTIX);		contract_array_index = 0;		graph2[node1][node2] = 0;			printf("vertix2 array\n");		graph2[vertix2 -1][0] = 0;		for(int i = 1; i < VERTIX; i++)		{			if(graph2[vertix2 -1][i] != vertix1)			{				contract_array[contract_array_index] = graph2[vertix2 -1][i];				contract_array_index++;			}			//printf("%d ", graph2[vertix2 -1][i])		;				}					printf("vertix1 array\n");		contract_array_index = 0;		for(int i = 1; i < VERTIX ; i++)		{			if(contract_array[contract_array_index] == 0)				break;			if(graph2[node1][i] == 0 && contract_array[contract_array_index] != 0 && contract_array_index <40 ) {				graph2[node1][i] = contract_array[contract_array_index];				contract_array_index++;			}			//printf("%d ", graph2[node1][i]);							}		for(int i = 1; i < VERTIX; i++)			contract_another_graph(vertix2, vertix1, i);				//usleep(2000000);		total_vertix--;		//random(&node_index, &node2_index);		//node1 = node_index;		//node2 = node2_index;		num = rand() % (200*200);		node1 = (int)(num/200);		node2 = num%200;			}			return;}/*void contract_graph(int node1, int node2, int** graph, int*total_vertix){	printf("\n\ncontract_ grpah %d %d %d \n", node1, node2, *total_vertix);	if(*total_vertix <= 2) 		return ;			vertix1 = graph[node1][0];	vertix2 = graph[node1][node2];	printf("vertix1 vertix2 %d %d\n", vertix1, vertix2);	if(vertix2 == 0 || vertix1 == 0 || vertix1 >200 || vertix2 >200)	{		printf("entering vertox2 = 0 || vertix =1\n");		int node_index, node2_index;		random(&node_index, &node2_index);		contract_graph(node_index, node2_index, graph, total_vertix);		return;					}	memset(contract_array, 0, VERTIX-2);	contract_array_index = 0;	graph[node1][node2] = 0;		printf("first for loop\n");	for(int i = 1; i < VERTIX; i++)	{		if(graph[vertix2 -1][i] != vertix1)		{			contract_array[contract_array_index] = graph[vertix2 -1][i];			contract_array_index++;		}	}	graph[vertix2 -1][0] = 0;	printf("contract array\n");	for(int i = 0; i< contract_array_index; i++)		printf("%d ", contract_array[i]);	printf("\n");	contract_array_index = 0;	for(int i = 0; i < VERTIX ; i++)	{		if(contract_array[contract_array_index] == 0)			break;		if(graph[node1][i] == 0 && contract_array[contract_array_index] != 0)		{			graph[node1][i] = contract_array[contract_array_index];			contract_array_index++;		}			}	printf("\n");		printf("get point again \n");	*total_vertix = *total_vertix -1;	random(&node_index, &node2_index);	contract_graph(node_index, node2_index, graph, total_vertix);		return;}*/int main(){		int graph[4][4] = {{1, 2, 3, 4,}, {2, 1, 4, 0}, {3,1, 4, 0}, {4, 1, 2, 3}};		int input_data[200][200] = {0};	ifstream f;        int x = 0;        f.open("input.txt");        char s[255];        while (!f.eof() && x <VERTIX)        {                f.getline(s, 254);                stringstream w(s);                int k =0;		while (!w.eof() && k < VERTIX)                {			w>>input_data[x][k] ;							k++;                }		x++;		        }        f.close();		graph2 =(int**)malloc(200* sizeof(int));	for(int row = 0; row < VERTIX; row++)	{		graph2[row] =(int*) malloc(sizeof(int) * VERTIX);		for(int j = 0; j < VERTIX; j++)			graph2[row][j] = input_data[row][j];	}				//log_txt = fopen("log.txt", "wb");				int node1, node2;	int total_vertix = VERTIX;	//random(&node1, &node2);	contract_graph( total_vertix);	printf("\n\n");			for(int i = 0; i< VERTIX; i++)	{	for(int j =0; j < VERTIX; j++)		{			if(graph2[i][0]!= 0) {				printf("%d ",graph2[i][j]);			if(j == VERTIX -1)				printf("\n");			}						}	}	//fclose(log_txt);	return 0;}